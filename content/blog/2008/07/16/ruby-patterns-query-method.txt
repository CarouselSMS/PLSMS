--- 
title:      'Ruby Patterns: Query Method'
created_at: 2008-07-16 16:33:57.327430 -04:00
layout:     post
summary:    Wherein our hero "discovers" and describes a particularly useful pattern that well help you keep your objects polite, well-behaved and properly encapsulated. Oy, what a beautiful specimen!
excerpt:    Patterns are learnable and reusable answers to common programming questions. They are decisions made in response to a number of different forces (or *tensions*). While these tensions may pull you in different directions, a properly written pattern resolves each of them harmoniously and provides a set of repeatable steps for reapplication.
filter:
  - erb
  - textile
--- 

Patterns are learnable and reusable answers to common programming questions. They are decisions made in response to a number of different forces (or *tensions*). While these tensions may pull you in different directions, a properly written pattern resolves each of them harmoniously and provides a set of repeatable steps for reapplication.

A pattern is only useful if it can be identified as applicable and then applied to solve a particular problem. Good patterns make clear the tensions involved in the decision-making process and the steps used in applying it.

The Query Method pattern answers a particularly common question: "How can I ask an object for information about itself". The tensions at play include a desire to maintain proper encapsulation, a desire to keep your code DRY(Don't Repeat Yourself), and a desire to maintain or improve the readability of the resulting solution. 

Let's look at an situation where various tensions pull us towards the need to make a harmonious design decision and attempt to derive a pattern for future use. As we do so, we will try to keep in mind the tensions at play and come up with steps that can be used to reapply the pattern.

If you don't really care about the discovery process and you want to skip straight to the pattern itself, it's "at the bottom":#bottom.

h3. Discovering A Pattern

In a recent blog post on "the value of learning encapsulation before learning rails":http://www.stephenchu.com/2008/06/learning-encapsulation-should-come.html, Stephen Chu gives an excellent example of a fragment of ruby code that could be improved by application of the Query Method pattern.

I'll use a slightly different example that better illustrates the tensions at&nbsp;play:

<% coderay(:lang => "ruby") do -%>
puts "#{@post.title} is recent." if @post.published_at < 2.days.ago
<% end %>

Hopefully this code will make you slightly uneasy even if you may not be able to say exactly why. The more you learn to listen to your code when it speaks to you like this, the better you will be able to identify hot spots for pattern application and other refactorings.

Let's look at this code in light of some of the different tensions:

h4. Encapsulation

In his post, Stephen points out that this code breaks encapsulation by yanking state information out of the object for comparison. More than that, the comparison is being made outside the context of the post. We can change the code a bit to make this more clear:

<% coderay(:lang => "ruby") do -%>
class Blog
  def recent_post_list
    @posts.each do |post|
      puts "#{post.title} is recent." if post.published_at < 2.days.ago
    end
  end
end
<% end %>

The blog that is creating this recent post list shouldn't and needn't know how to determine if a post is recent. This is the post's responsibility and the comparison should be made inside the post. This desire for encapsulation is the first tension.

h4. Don't Repeat Yourself

This code seems simple enough. It does one thing and appears to do it efficiently. There is no violation of DRY yet, but it isn't to difficult to imagine other situations where we might need to know if a post is recent.

Let's say we are generating an HTML page and we want to apply a special class to recent posts. We will need to duplicate this logic inside that method as well. Now, what if we later decide that three day old posts should be recent, not just two day old posts? Now we have to find each instance of this code fragment so that we can change it&nbsp;appropriately. 

What a pain! Clearly this code is not DRY and its maintainability is compromised as a result. This is the second tension.

h4. Readability

This code looks pretty readable. @published_at@ and @2.days.ago@ reveal their intention quite clearly. If any improvement is to be made, you may think, it will be incremental and relatively small. Nevertheless, improved readability means improved maintainability, so it is always worth consideration. This is the third tension.

h3. Composing A Pattern

This list of tensions isn't nearly exhaustive but it should be sufficient for us to begin considering a solution. How can we improve this code in a way that most effectively addresses all of tensions?

This is a case where the tensions are not in direct opposition. It should be pretty easy to come up with a solution that addresses all of them. Let's try to formulate such a pattern, including the steps necessary to reapply it.

h4. Encapsulation and DRY

First, we'll start by encapsulating the comparison inside the post object:

<% coderay(:lang => "ruby") do -%>
class Post
  def is_published_at_less_that_two_days_ago?
    published_at < 2.days.ago
  end
end

puts "#{@post.title} is recent." if @post.is_published_at_less_that_two_days_ago?
<% end %>

This resolves the encapsulation tension. By factoring the behavior to a single location it also resolves the DRY tension. It doesn't do much for our readability tension, though. Let's see what we can do about that.

h4. Readability

Patterns can often be improved by the inclusion of smaller, more granular patterns. In this case, the readability can be improved by providing an Intention Revealing Selector. An intention revealing selector is, as the name suggests, one that informs to the user of the *intention* of the&nbsp;method. 

Our current selector informs the user of the method's implementation. It answers the "how" question. An Intention Revealing Selector answers the more useful "why" question as in: why does this method exist?

So: why *does* this method exist? It exists so that it can be used to ask the post if it is recent or not. An intention revealing name for this selector would use the word "recent" to answer the "why" question.

The Ruby idiom for a method that is intended to return a boolean is to end it with a "?". Let's apply the Intention Revealing Selector by giving the method an intention revealing name and ending it with a "?"<notextile>.</notextile>

<% coderay(:lang => "ruby") do -%>
class Post
  def recent?
    published_at < 2.days.ago
  end
end

puts "#{post.title} is recent." if post.recent?
<% end %>

I think you'll agree that this new method resolves all of the tensions harmoniously. The behavior is properly encapsulated, it is DRY because it is defined Once And Only Once, and it is significantly more readable than the original because it reveals its intention rather than its implementation.

Thus, we can formulate the Query Method Pattern as such:

<h3 id="bottom">Formulating The Query Method Pattern</h3>

When you want to encapsulate the behavior of asking an object about itself so that you can DRY it and make it more readable, follow these steps:

<dl>
  <dt>Query Method</dt>
  <dd>*1.* Write a method that performs the query.</dd>
  <dd>*2.* Put it inside the object that holds the information being queried.</dd>
  <dd>*3.* Give it an Intention Revealing Selector.</dd>
</dl>

The next time you're faced with this design question, you can use this pattern to make a decision that leads to better encapsulated, more DRY, more readable and ultimately more maintainable code.